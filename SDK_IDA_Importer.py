# SDK_IDA_Importer.py
# Auto-generated IDA Pro SDK Importer
# Generated by SzakÃ¡cs SDK Generator
# Made by: Respecter (UC: https://www.unknowncheats.me/forum/members/275886.html)
# Compatible with IDA Pro 9.x

import idaapi
import idc
import ida_typeinf
import ida_name
import json
import os

# ========== Configuration ==========
ENABLE_IMPORT_TYPES = True      # Create struct definitions in IDA
ENABLE_IMPORT_FUNCTIONS = True  # Set function names and signatures
ENABLE_IMPORT_VTABLES = True    # Name vtable pointers
ENABLE_APPLY_TYPES = False      # Actually apply types to memory (use with caution)

# ========== Helper Functions ==========

def log(msg):
    """Print log message to IDA output"""
    print("[SDK_IDA] " + msg)

def convert_cpp_type_to_ida_tinfo(cpp_type):
    """Convert C++ type names to IDA tinfo_t objects"""
    type_map = {
        'uint8_t': ida_typeinf.BTF_UINT8,
        'uint16_t': ida_typeinf.BTF_UINT16,
        'uint32_t': ida_typeinf.BTF_UINT32,
        'uint64_t': ida_typeinf.BTF_UINT64,
        'int8_t': ida_typeinf.BTF_INT8,
        'int16_t': ida_typeinf.BTF_INT16,
        'int32_t': ida_typeinf.BTF_INT32,
        'int64_t': ida_typeinf.BTF_INT64,
        'bool': ida_typeinf.BTF_BOOL,
        'float': ida_typeinf.BTF_FLOAT,
        'double': ida_typeinf.BTF_DOUBLE,
        'char': ida_typeinf.BTF_CHAR,
        'void': ida_typeinf.BTF_VOID,
    }
    
    # Handle pointer types
    if cpp_type.endswith('*'):
        base_type = cpp_type[:-1].strip().replace('class ', '').replace('struct ', '')
        base_tif = convert_cpp_type_to_ida_tinfo(base_type)
        ptr_tif = ida_typeinf.tinfo_t()
        if ptr_tif.create_ptr(base_tif):
            return ptr_tif
        # Fallback to void pointer
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_VOID | ida_typeinf.BTF_PTR)
    
    # Handle references (convert to pointers for IDA)
    if cpp_type.endswith('&'):
        base_type = cpp_type[:-1].strip().replace('class ', '').replace('struct ', '')
        base_tif = convert_cpp_type_to_ida_tinfo(base_type)
        ptr_tif = ida_typeinf.tinfo_t()
        if ptr_tif.create_ptr(base_tif):
            return ptr_tif
        return ida_typeinf.tinfo_t(ida_typeinf.BTF_VOID | ida_typeinf.BTF_PTR)
    
    # Check direct mappings
    clean_type = cpp_type.replace('class ', '').replace('struct ', '').strip()
    
    if clean_type in type_map:
        return ida_typeinf.tinfo_t(type_map[clean_type])
    
    # Try to get as named type (for custom classes/structs)
    tif = ida_typeinf.tinfo_t()
    if tif.get_named_type(None, clean_type):
        return tif
    
    # Default to void pointer for unknown types
    return ida_typeinf.tinfo_t(ida_typeinf.BTF_VOID | ida_typeinf.BTF_PTR)

def create_struct_in_ida(struct_name, size, members):
    """Create a struct definition in IDA using type information system"""
    try:
        # Check if struct already exists
        tif = ida_typeinf.tinfo_t()
        if tif.get_named_type(None, struct_name):
            log(f"Struct {struct_name} already exists, skipping...")
            return True
        
        # Create UDT (User Defined Type)
        udt = ida_typeinf.udt_type_data_t()
        udm = ida_typeinf.udm_t()
        
        # Sort members by offset to ensure proper structure
        sorted_members = sorted(members, key=lambda m: m['offset'])
        
        # Add members
        current_offset = 0
        for member in sorted_members:
            member_name = member['name']
            member_offset = member['offset']
            member_size = member['size']
            
            # Add padding if needed
            if member_offset > current_offset:
                padding_size = member_offset - current_offset
                udm.name = f"pad_{current_offset:X}"
                udm.type = ida_typeinf.tinfo_t(ida_typeinf.BTF_BYTE)
                # Create array for padding
                array_tif = ida_typeinf.tinfo_t()
                if array_tif.create_array(udm.type, padding_size, 0):
                    udm.type = array_tif
                udt.push_back(udm)
                current_offset += padding_size
            
            # Add the actual member
            udm.name = member_name
            udm.offset = member_offset
            
            # Try to determine type based on size if we can't convert
            member_type_str = member.get('type', 'Unknown')
            udm.type = convert_cpp_type_to_ida_tinfo(member_type_str)
            
            # If type couldn't be determined, create a byte array of the right size
            actual_size = udm.type.get_size()
            if actual_size != member_size and member_size > 0:
                byte_tif = ida_typeinf.tinfo_t(ida_typeinf.BTF_BYTE)
                array_tif = ida_typeinf.tinfo_t()
                if array_tif.create_array(byte_tif, member_size, 0):
                    udm.type = array_tif
            
            udt.push_back(udm)
            current_offset = member_offset + member_size
        
        # Add final padding if needed to reach the struct size
        if current_offset < size:
            padding_size = size - current_offset
            udm.name = f"pad_{current_offset:X}"
            udm.type = ida_typeinf.tinfo_t(ida_typeinf.BTF_BYTE)
            array_tif = ida_typeinf.tinfo_t()
            if array_tif.create_array(udm.type, padding_size, 0):
                udm.type = array_tif
            udt.push_back(udm)
        
        # Create the struct
        tif = ida_typeinf.tinfo_t()
        if not tif.create_udt(udt, ida_typeinf.BTF_STRUCT):
            log(f"Failed to create UDT for {struct_name}")
            return False
        
        # Set the named type
        if not tif.set_named_type(None, struct_name, ida_typeinf.NTF_REPLACE):
            log(f"Failed to set named type for {struct_name}")
            return False
        
        log(f"Created struct: {struct_name} (size: 0x{size:X})")
        return True
        
    except Exception as e:
        log(f"Error creating struct {struct_name}: {str(e)}")
        return False

def set_function_name_and_type(rva, func_name, return_type, params, is_static, class_name):
    """Set function name and signature at RVA"""
    try:
        if rva == 0:
            return  # Skip JIT functions
        
        ea = idaapi.get_imagebase() + rva
        
        # Set function name
        full_name = f"{class_name}::{func_name}"
        if ida_name.set_name(ea, full_name, ida_name.SN_NOWARN | ida_name.SN_NOCHECK):
            log(f"Set function name: {full_name} @ 0x{rva:X}")
        
        # Build function type using tinfo
        # For now, we'll use simple string-based type setting as it's more reliable
        # Create parameter string
        param_list = []
        for p in params:
            param_type = p['type'].replace('class ', '').replace('struct ', '')
            param_name = p['name']
            param_list.append(f"{param_type} {param_name}")
        
        param_str = ", ".join(param_list) if param_list else "void"
        ret_type = return_type.replace('class ', '').replace('struct ', '') if return_type else "void"
        
        # Build signature
        signature = f"{ret_type} __fastcall {full_name}({param_str})"
        
        # Try to set type using idc
        if idc.SetType(ea, signature):
            log(f"Set function type: {full_name}")
        
    except Exception as e:
        log(f"Error setting function {func_name}: {str(e)}")

def name_vtable(rva, class_name, method_count):
    """Name the vtable pointer"""
    try:
        if rva == 0 or method_count == 0:
            return
        
        ea = idaapi.get_imagebase() + rva
        vtable_name = f"vtable_{class_name}"
        
        if ida_name.set_name(ea, vtable_name, ida_name.SN_NOWARN):
            log(f"Named vtable: {vtable_name} @ 0x{rva:X} ({method_count} methods)")
        
    except Exception as e:
        log(f"Error naming vtable for {class_name}: {str(e)}")

# ========== Main Import Function ==========

def import_sdk_data(json_path):
    """Main function to import SDK data into IDA"""
    log("=" * 60)
    log("SDK IDA Importer Started (IDA 9.x)")
    log("=" * 60)
    log(f"Configuration:")
    log(f"  Import Types: {ENABLE_IMPORT_TYPES}")
    log(f"  Import Functions: {ENABLE_IMPORT_FUNCTIONS}")
    log(f"  Import VTables: {ENABLE_IMPORT_VTABLES}")
    log(f"  Apply Types: {ENABLE_APPLY_TYPES}")
    log("=" * 60)
    
    # Load JSON data
    if not os.path.exists(json_path):
        log(f"ERROR: JSON file not found: {json_path}")
        return
    
    log(f"Loading JSON: {json_path}")
    with open(json_path, 'r', encoding='utf-8') as f:
        data = json.load(f)
    
    log(f"Generator: {data.get('generator', 'Unknown')}")
    log(f"Date: {data.get('date', 'Unknown')}")
    log(f"Game Base: {data.get('game_base', 'Unknown')}")
    log("=" * 60)
    
    # Import Enums (as comments for reference)
    enums = data.get('enums', [])
    log(f"Found {len(enums)} enums")
    
    # Import Classes
    classes = data.get('classes', [])
    log(f"Found {len(classes)} classes/structs")
    
    # Phase 1: Create struct definitions
    if ENABLE_IMPORT_TYPES:
        log("\n[Phase 1] Creating struct definitions...")
        success_count = 0
        for cls in classes:
            struct_name = ("U" if cls['is_class'] else "F") + cls['name']
            if create_struct_in_ida(struct_name, cls['size'], cls['properties']):
                success_count += 1
        log(f"Created {success_count}/{len(classes)} structs")
    
    # Phase 2: Import functions
    if ENABLE_IMPORT_FUNCTIONS:
        log("\n[Phase 2] Importing functions...")
        func_count = 0
        for cls in classes:
            class_name = ("U" if cls['is_class'] else "F") + cls['name']
            for func in cls['functions']:
                set_function_name_and_type(
                    int(func['rva'], 16),
                    func['name'],
                    func['return_type'],
                    func['parameters'],
                    func['is_static'],
                    class_name
                )
                func_count += 1
        log(f"Imported {func_count} functions")
    
    # Phase 3: Name vtables
    if ENABLE_IMPORT_VTABLES:
        log("\n[Phase 3] Naming vtables...")
        vtable_count = 0
        for cls in classes:
            if cls['vtable_methods'] > 0:
                class_name = ("U" if cls['is_class'] else "F") + cls['name']
                name_vtable(
                    int(cls['vtable_rva'], 16),
                    class_name,
                    cls['vtable_methods']
                )
                vtable_count += 1
        log(f"Named {vtable_count} vtables")
    
    log("=" * 60)
    log("SDK Import Completed!")
    log("=" * 60)

# ========== Entry Point ==========

def main():
    """Entry point for the script"""
    # You can modify this path or make it ask user
    json_path = r"C:\embark\SDK_IDA.json"
    
    # Ask user for confirmation
    msg = f"Import SDK from:\n{json_path}\n\nContinue?"
    if idaapi.ask_yn(1, msg) == 1:
        import_sdk_data(json_path)
    else:
        log("Import cancelled by user")

if __name__ == "__main__":
    main()
